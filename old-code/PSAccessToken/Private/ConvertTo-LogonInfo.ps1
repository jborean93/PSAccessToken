# Copyright: (c) 2019, Jordan Borean (@jborean93) <jborean93@gmail.com>
# MIT License (see LICENSE or https://opensource.org/licenses/MIT)

Function ConvertTo-LogonInfo {
    <#
    .SYNOPSIS
    Used to create a LogonInfo output object with the raw inputs from LsaLogonUser.

    .PARAMETER Token
    The access token generated by LsaLogonUser.

    .PARAMETER ProfileBuffer
    A pointer to the profile buffer from LsaLogonUser.

    .PARAMETER Username
    The username that was used during the logon.

    .PARAMETER Domain
    The domain name that was used during the logon, can be null or empty.

    .PARAMETER LogonType
    The logon type that was used during the logon.

    .PARAMETER LogonId
    The LUID representing the LogonID generated by LSA.

    .PARAMETER QuotaLimits
    The PSAccessToken.QUOTA_LIMITS structure generated by LsaLogonUser.
    #>
    [OutputType('PSAccessToken.LogonInfo')]
    [CmdletBinding()]
    Param (
        [Parameter(Mandatory=$true)]
        [PInvokeHelper.SafeNativeHandle]
        $Token,

        [Parameter(Mandatory=$true)]
        [System.IntPtr]
        $ProfileBuffer,

        [Parameter(Mandatory=$true)]
        [System.String]
        $Username,

        [Parameter(Mandatory=$true)]
        [AllowNull()]
        [AllowEmptyString()]
        [System.String]
        $Domain,

        [Parameter(Mandatory=$true)]
        [PSAccessToken.LogonType]
        $LogonType,

        [Parameter(Mandatory=$true)]
        [PSAccessToken.LUID]
        $LogonId,

        [PSAccessToken.QUOTA_LIMITS]
        $QuotaLimits
    )

    $logon_info = [PSCustomObject]@{
        # Common properties
        PSTypeName = 'PSAccessToken.LogonInfo'
        Token = $Token
        Username = $Username
        Domain = $Domain
        LogonType = $LogonType
        LogonId = $LogonId
        Profile = $null

        # Quota Limits
        PagedPoolLimit = $QuotaLimits.PagedPoolLimit.ToUInt64()
        NonPagedPoolLimit = $QuotaLimits.NonPagedPoolLimit.ToUInt64()
        MinimumWorkingSetSize = $QuotaLimits.MinimumWorkingSetSize.ToUInt64()
        MaximumWorkingSetSize = $QuotaLimits.MaximumWorkingSetSize.ToUInt64()
        PagefileLimit = $QuotaLimits.PagefileLimit.ToUInt64()
        TimeLimit = $QuotaLimits.TimeLimit
    }

    if ($ProfileBuffer -eq [System.IntPtr]::Zero) {
        return $logon_info
    }

    # Get the first 4 bytes to determine the profile type
    $profile_type = Convert-PointerToUInt32 -Ptr $ProfileBuffer
    switch($profile_type) {
        ([System.UInt32][PSAccessToken.ProfileBufferType]::Interactive) {
            $pb_type = [PSAccessToken.LSA_INTERACTIVE_PROFILE]
            $type_name = 'PSAccessToken.InteractiveProfile'
            $passthru_props = @('MessageType', 'LogonCount', 'BadPasswordCount', 'UserFlags')
            $filetime_props = @(
                'LogonTime', 'LogoffTime', 'KickOffTime', 'PasswordLastSet',
                'PasswordCanChange', 'PasswordMustChange'
            )
            $string_props = @(
                'LogonScript', 'HomeDirectory', 'FullName',
                'ProfilePath', 'HomeDirectoryDrive', 'LogonServer'
            )
        }
        ([System.UInt32][PSAccessToken.ProfileBufferType]::Lm20) {
            $pb_type = [PSAccessToken.LSA_LM20_LOGON_PROFILE]
            $type_name = 'PSAccessToken.Lm20Profile'
            $passthru_props = @('MessageType', 'UserFlags', 'UserSessionKey', 'LanmanSessionKey')
            $filetime_props = @('KickOffTime', 'LogoffTime')
            $string_props = @('LogonDomainName', 'LogonServer', 'UserParameters')
        }
        default { return $logon_info }
    }

    $pb = [System.Runtime.InteropServices.Marshal]::PtrToStructure($ProfileBuffer, [Type]$pb_type)
    $logon_info.Profile = [PSCustomObject]@{
        PSTypeName = $type_name
    }

    # Set passthru properties
    $passthru_props | ForEach-Object -Process {
        $logon_info.Profile | Add-Member -MemberType NoteProperty -Name $_ -Value $pb.$_
    }

    # Parse the FileTime properties
    $filetime_props | ForEach-Object -Process {
        $int_value = $pb.$_
        $datetime_value = $null

        if ($null -ne $int_value -and $int_value -gt 0 -and $int_value -ne [System.Int64]::MaxValue) {
            $datetime_value = [System.DateTime]::FromFileTime($int_value)
        }

        $logon_info.Profile | Add-Member -MemberType NoteProperty -Name $_ -Value $datetime_value
    }

    # Parse the LSA_UNICODE_STRING properties
    $string_props | ForEach-Object -Process {
        $lsa_string = $pb.$_
        $string_value = $null

        if ($lsa_string.Length -gt 0) {
            $string_value = [System.Runtime.InteropServices.Marshal]::PtrToStringUni(
                $lsa_string.Buffer, $lsa_string.Length / 2  # Unicode string is 2 bytes per char.
            )
        }

        $logon_info.Profile | Add-Member -MemberType NoteProperty -Name $_ -Value $string_value
    }

    return $logon_info
}